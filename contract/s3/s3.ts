// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "s3/s3.proto" (package "s3", syntax proto3)
// tslint:disable
import { Response } from "../common/common";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * Bucket message
 *
 * @generated from protobuf message s3.Bucket
 */
export interface Bucket {
    /**
     * @generated from protobuf field: string bucket_name = 1;
     */
    bucketName: string; // Название бакета
}
/**
 * Image message
 *
 * @generated from protobuf message s3.Image
 */
export interface Image {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string; // Уникальный идентификатор изображения
}
/**
 * ImageWithBucket message
 *
 * @generated from protobuf message s3.ImageWithBucket
 */
export interface ImageWithBucket {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string; // Уникальный идентификатор изображения
    /**
     * @generated from protobuf field: string bucket_name = 2;
     */
    bucketName: string; // Название бакета
}
/**
 * Request and response messages for each function
 *
 * @generated from protobuf message s3.RegisterBucketRequest
 */
export interface RegisterBucketRequest {
    /**
     * @generated from protobuf field: string bucket_name = 1;
     */
    bucketName: string;
}
/**
 * @generated from protobuf message s3.RegisterBucketResponse
 */
export interface RegisterBucketResponse {
    /**
     * @generated from protobuf field: s3.Bucket bucket = 1;
     */
    bucket?: Bucket;
    /**
     * @generated from protobuf field: uint32 status = 2;
     */
    status: number;
}
/**
 * @generated from protobuf message s3.HasBucketRequest
 */
export interface HasBucketRequest {
    /**
     * @generated from protobuf field: string bucket_name = 1;
     */
    bucketName: string;
}
/**
 * @generated from protobuf message s3.HasBucketResponse
 */
export interface HasBucketResponse {
    /**
     * @generated from protobuf field: bool exists = 1;
     */
    exists: boolean;
    /**
     * @generated from protobuf field: uint32 status = 2;
     */
    status: number;
}
/**
 * @generated from protobuf message s3.UnregisterBucketRequest
 */
export interface UnregisterBucketRequest {
    /**
     * @generated from protobuf field: string bucket_name = 1;
     */
    bucketName: string;
}
/**
 * @generated from protobuf message s3.GetAllBucketsRequest
 */
export interface GetAllBucketsRequest {
}
/**
 * @generated from protobuf message s3.GetAllBucketsResponse
 */
export interface GetAllBucketsResponse {
    /**
     * @generated from protobuf field: repeated s3.Bucket buckets = 1;
     */
    buckets: Bucket[];
    /**
     * @generated from protobuf field: uint32 status = 2;
     */
    status: number;
}
/**
 * @generated from protobuf message s3.CreateImageRequest
 */
export interface CreateImageRequest {
    /**
     * @generated from protobuf field: string bucket_name = 1;
     */
    bucketName: string;
    /**
     * @generated from protobuf field: bytes file = 2;
     */
    file: Uint8Array;
    /**
     * @generated from protobuf field: string file_extension = 3;
     */
    fileExtension: string;
    /**
     * @generated from protobuf field: optional float quality = 4;
     */
    quality?: number;
    /**
     * @generated from protobuf field: optional int32 max_size = 5;
     */
    maxSize?: number;
}
/**
 * @generated from protobuf message s3.CreateImageResponse
 */
export interface CreateImageResponse {
    /**
     * @generated from protobuf field: s3.Image image = 1;
     */
    image?: Image;
    /**
     * @generated from protobuf field: uint32 status = 2;
     */
    status: number;
}
/**
 * @generated from protobuf message s3.GetImageRequest
 */
export interface GetImageRequest {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
}
/**
 * @generated from protobuf message s3.GetImageResponse
 */
export interface GetImageResponse {
    /**
     * @generated from protobuf field: s3.Image image = 1;
     */
    image?: Image;
    /**
     * @generated from protobuf field: uint32 status = 2;
     */
    status: number;
}
/**
 * @generated from protobuf message s3.GetImageWithBucketRequest
 */
export interface GetImageWithBucketRequest {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
}
/**
 * @generated from protobuf message s3.GetImageWithBucketResponse
 */
export interface GetImageWithBucketResponse {
    /**
     * @generated from protobuf field: s3.ImageWithBucket image_with_bucket = 1;
     */
    imageWithBucket?: ImageWithBucket;
    /**
     * @generated from protobuf field: uint32 status = 2;
     */
    status: number;
}
/**
 * @generated from protobuf message s3.DeleteImageRequest
 */
export interface DeleteImageRequest {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
}
/**
 * @generated from protobuf message s3.GetAllImagesRequest
 */
export interface GetAllImagesRequest {
    /**
     * @generated from protobuf field: int32 limit = 1;
     */
    limit: number;
}
/**
 * @generated from protobuf message s3.GetAllImagesResponse
 */
export interface GetAllImagesResponse {
    /**
     * @generated from protobuf field: repeated s3.Image images = 1;
     */
    images: Image[];
    /**
     * @generated from protobuf field: uint32 status = 2;
     */
    status: number;
}
/**
 * @generated from protobuf message s3.GetImagesInBucketRequest
 */
export interface GetImagesInBucketRequest {
    /**
     * @generated from protobuf field: string bucket_name = 1;
     */
    bucketName: string;
    /**
     * @generated from protobuf field: int32 limit = 2;
     */
    limit: number;
}
/**
 * @generated from protobuf message s3.GetImagesInBucketResponse
 */
export interface GetImagesInBucketResponse {
    /**
     * @generated from protobuf field: repeated s3.Image images = 1;
     */
    images: Image[];
    /**
     * @generated from protobuf field: uint32 status = 2;
     */
    status: number;
}
// @generated message type with reflection information, may provide speed optimized methods
class Bucket$Type extends MessageType<Bucket> {
    constructor() {
        super("s3.Bucket", [
            { no: 1, name: "bucket_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Bucket>): Bucket {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bucketName = "";
        if (value !== undefined)
            reflectionMergePartial<Bucket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Bucket): Bucket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string bucket_name */ 1:
                    message.bucketName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Bucket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string bucket_name = 1; */
        if (message.bucketName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.bucketName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.Bucket
 */
export const Bucket = new Bucket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Image$Type extends MessageType<Image> {
    constructor() {
        super("s3.Image", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Image>): Image {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<Image>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Image): Image {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Image, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.Image
 */
export const Image = new Image$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImageWithBucket$Type extends MessageType<ImageWithBucket> {
    constructor() {
        super("s3.ImageWithBucket", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "bucket_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ImageWithBucket>): ImageWithBucket {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.bucketName = "";
        if (value !== undefined)
            reflectionMergePartial<ImageWithBucket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImageWithBucket): ImageWithBucket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string bucket_name */ 2:
                    message.bucketName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImageWithBucket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string bucket_name = 2; */
        if (message.bucketName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.bucketName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.ImageWithBucket
 */
export const ImageWithBucket = new ImageWithBucket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterBucketRequest$Type extends MessageType<RegisterBucketRequest> {
    constructor() {
        super("s3.RegisterBucketRequest", [
            { no: 1, name: "bucket_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RegisterBucketRequest>): RegisterBucketRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bucketName = "";
        if (value !== undefined)
            reflectionMergePartial<RegisterBucketRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterBucketRequest): RegisterBucketRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string bucket_name */ 1:
                    message.bucketName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterBucketRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string bucket_name = 1; */
        if (message.bucketName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.bucketName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.RegisterBucketRequest
 */
export const RegisterBucketRequest = new RegisterBucketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterBucketResponse$Type extends MessageType<RegisterBucketResponse> {
    constructor() {
        super("s3.RegisterBucketResponse", [
            { no: 1, name: "bucket", kind: "message", T: () => Bucket },
            { no: 2, name: "status", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<RegisterBucketResponse>): RegisterBucketResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial<RegisterBucketResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterBucketResponse): RegisterBucketResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* s3.Bucket bucket */ 1:
                    message.bucket = Bucket.internalBinaryRead(reader, reader.uint32(), options, message.bucket);
                    break;
                case /* uint32 status */ 2:
                    message.status = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterBucketResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* s3.Bucket bucket = 1; */
        if (message.bucket)
            Bucket.internalBinaryWrite(message.bucket, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).uint32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.RegisterBucketResponse
 */
export const RegisterBucketResponse = new RegisterBucketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HasBucketRequest$Type extends MessageType<HasBucketRequest> {
    constructor() {
        super("s3.HasBucketRequest", [
            { no: 1, name: "bucket_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HasBucketRequest>): HasBucketRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bucketName = "";
        if (value !== undefined)
            reflectionMergePartial<HasBucketRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HasBucketRequest): HasBucketRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string bucket_name */ 1:
                    message.bucketName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HasBucketRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string bucket_name = 1; */
        if (message.bucketName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.bucketName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.HasBucketRequest
 */
export const HasBucketRequest = new HasBucketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HasBucketResponse$Type extends MessageType<HasBucketResponse> {
    constructor() {
        super("s3.HasBucketResponse", [
            { no: 1, name: "exists", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "status", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<HasBucketResponse>): HasBucketResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.exists = false;
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial<HasBucketResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HasBucketResponse): HasBucketResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool exists */ 1:
                    message.exists = reader.bool();
                    break;
                case /* uint32 status */ 2:
                    message.status = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HasBucketResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool exists = 1; */
        if (message.exists !== false)
            writer.tag(1, WireType.Varint).bool(message.exists);
        /* uint32 status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).uint32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.HasBucketResponse
 */
export const HasBucketResponse = new HasBucketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnregisterBucketRequest$Type extends MessageType<UnregisterBucketRequest> {
    constructor() {
        super("s3.UnregisterBucketRequest", [
            { no: 1, name: "bucket_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UnregisterBucketRequest>): UnregisterBucketRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bucketName = "";
        if (value !== undefined)
            reflectionMergePartial<UnregisterBucketRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnregisterBucketRequest): UnregisterBucketRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string bucket_name */ 1:
                    message.bucketName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnregisterBucketRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string bucket_name = 1; */
        if (message.bucketName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.bucketName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.UnregisterBucketRequest
 */
export const UnregisterBucketRequest = new UnregisterBucketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAllBucketsRequest$Type extends MessageType<GetAllBucketsRequest> {
    constructor() {
        super("s3.GetAllBucketsRequest", []);
    }
    create(value?: PartialMessage<GetAllBucketsRequest>): GetAllBucketsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetAllBucketsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllBucketsRequest): GetAllBucketsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetAllBucketsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.GetAllBucketsRequest
 */
export const GetAllBucketsRequest = new GetAllBucketsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAllBucketsResponse$Type extends MessageType<GetAllBucketsResponse> {
    constructor() {
        super("s3.GetAllBucketsResponse", [
            { no: 1, name: "buckets", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Bucket },
            { no: 2, name: "status", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetAllBucketsResponse>): GetAllBucketsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.buckets = [];
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial<GetAllBucketsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllBucketsResponse): GetAllBucketsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated s3.Bucket buckets */ 1:
                    message.buckets.push(Bucket.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 status */ 2:
                    message.status = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAllBucketsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated s3.Bucket buckets = 1; */
        for (let i = 0; i < message.buckets.length; i++)
            Bucket.internalBinaryWrite(message.buckets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).uint32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.GetAllBucketsResponse
 */
export const GetAllBucketsResponse = new GetAllBucketsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateImageRequest$Type extends MessageType<CreateImageRequest> {
    constructor() {
        super("s3.CreateImageRequest", [
            { no: 1, name: "bucket_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "file", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "file_extension", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "quality", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "max_size", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CreateImageRequest>): CreateImageRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bucketName = "";
        message.file = new Uint8Array(0);
        message.fileExtension = "";
        if (value !== undefined)
            reflectionMergePartial<CreateImageRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateImageRequest): CreateImageRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string bucket_name */ 1:
                    message.bucketName = reader.string();
                    break;
                case /* bytes file */ 2:
                    message.file = reader.bytes();
                    break;
                case /* string file_extension */ 3:
                    message.fileExtension = reader.string();
                    break;
                case /* optional float quality */ 4:
                    message.quality = reader.float();
                    break;
                case /* optional int32 max_size */ 5:
                    message.maxSize = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateImageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string bucket_name = 1; */
        if (message.bucketName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.bucketName);
        /* bytes file = 2; */
        if (message.file.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.file);
        /* string file_extension = 3; */
        if (message.fileExtension !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.fileExtension);
        /* optional float quality = 4; */
        if (message.quality !== undefined)
            writer.tag(4, WireType.Bit32).float(message.quality);
        /* optional int32 max_size = 5; */
        if (message.maxSize !== undefined)
            writer.tag(5, WireType.Varint).int32(message.maxSize);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.CreateImageRequest
 */
export const CreateImageRequest = new CreateImageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateImageResponse$Type extends MessageType<CreateImageResponse> {
    constructor() {
        super("s3.CreateImageResponse", [
            { no: 1, name: "image", kind: "message", T: () => Image },
            { no: 2, name: "status", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CreateImageResponse>): CreateImageResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial<CreateImageResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateImageResponse): CreateImageResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* s3.Image image */ 1:
                    message.image = Image.internalBinaryRead(reader, reader.uint32(), options, message.image);
                    break;
                case /* uint32 status */ 2:
                    message.status = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateImageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* s3.Image image = 1; */
        if (message.image)
            Image.internalBinaryWrite(message.image, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).uint32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.CreateImageResponse
 */
export const CreateImageResponse = new CreateImageResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetImageRequest$Type extends MessageType<GetImageRequest> {
    constructor() {
        super("s3.GetImageRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetImageRequest>): GetImageRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<GetImageRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetImageRequest): GetImageRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetImageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.GetImageRequest
 */
export const GetImageRequest = new GetImageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetImageResponse$Type extends MessageType<GetImageResponse> {
    constructor() {
        super("s3.GetImageResponse", [
            { no: 1, name: "image", kind: "message", T: () => Image },
            { no: 2, name: "status", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetImageResponse>): GetImageResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial<GetImageResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetImageResponse): GetImageResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* s3.Image image */ 1:
                    message.image = Image.internalBinaryRead(reader, reader.uint32(), options, message.image);
                    break;
                case /* uint32 status */ 2:
                    message.status = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetImageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* s3.Image image = 1; */
        if (message.image)
            Image.internalBinaryWrite(message.image, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).uint32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.GetImageResponse
 */
export const GetImageResponse = new GetImageResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetImageWithBucketRequest$Type extends MessageType<GetImageWithBucketRequest> {
    constructor() {
        super("s3.GetImageWithBucketRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetImageWithBucketRequest>): GetImageWithBucketRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<GetImageWithBucketRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetImageWithBucketRequest): GetImageWithBucketRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetImageWithBucketRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.GetImageWithBucketRequest
 */
export const GetImageWithBucketRequest = new GetImageWithBucketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetImageWithBucketResponse$Type extends MessageType<GetImageWithBucketResponse> {
    constructor() {
        super("s3.GetImageWithBucketResponse", [
            { no: 1, name: "image_with_bucket", kind: "message", T: () => ImageWithBucket },
            { no: 2, name: "status", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetImageWithBucketResponse>): GetImageWithBucketResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial<GetImageWithBucketResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetImageWithBucketResponse): GetImageWithBucketResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* s3.ImageWithBucket image_with_bucket */ 1:
                    message.imageWithBucket = ImageWithBucket.internalBinaryRead(reader, reader.uint32(), options, message.imageWithBucket);
                    break;
                case /* uint32 status */ 2:
                    message.status = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetImageWithBucketResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* s3.ImageWithBucket image_with_bucket = 1; */
        if (message.imageWithBucket)
            ImageWithBucket.internalBinaryWrite(message.imageWithBucket, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).uint32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.GetImageWithBucketResponse
 */
export const GetImageWithBucketResponse = new GetImageWithBucketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteImageRequest$Type extends MessageType<DeleteImageRequest> {
    constructor() {
        super("s3.DeleteImageRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteImageRequest>): DeleteImageRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteImageRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteImageRequest): DeleteImageRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteImageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.DeleteImageRequest
 */
export const DeleteImageRequest = new DeleteImageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAllImagesRequest$Type extends MessageType<GetAllImagesRequest> {
    constructor() {
        super("s3.GetAllImagesRequest", [
            { no: 1, name: "limit", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetAllImagesRequest>): GetAllImagesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.limit = 0;
        if (value !== undefined)
            reflectionMergePartial<GetAllImagesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllImagesRequest): GetAllImagesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 limit */ 1:
                    message.limit = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAllImagesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 limit = 1; */
        if (message.limit !== 0)
            writer.tag(1, WireType.Varint).int32(message.limit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.GetAllImagesRequest
 */
export const GetAllImagesRequest = new GetAllImagesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAllImagesResponse$Type extends MessageType<GetAllImagesResponse> {
    constructor() {
        super("s3.GetAllImagesResponse", [
            { no: 1, name: "images", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Image },
            { no: 2, name: "status", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetAllImagesResponse>): GetAllImagesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.images = [];
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial<GetAllImagesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllImagesResponse): GetAllImagesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated s3.Image images */ 1:
                    message.images.push(Image.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 status */ 2:
                    message.status = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAllImagesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated s3.Image images = 1; */
        for (let i = 0; i < message.images.length; i++)
            Image.internalBinaryWrite(message.images[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).uint32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.GetAllImagesResponse
 */
export const GetAllImagesResponse = new GetAllImagesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetImagesInBucketRequest$Type extends MessageType<GetImagesInBucketRequest> {
    constructor() {
        super("s3.GetImagesInBucketRequest", [
            { no: 1, name: "bucket_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "limit", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetImagesInBucketRequest>): GetImagesInBucketRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bucketName = "";
        message.limit = 0;
        if (value !== undefined)
            reflectionMergePartial<GetImagesInBucketRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetImagesInBucketRequest): GetImagesInBucketRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string bucket_name */ 1:
                    message.bucketName = reader.string();
                    break;
                case /* int32 limit */ 2:
                    message.limit = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetImagesInBucketRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string bucket_name = 1; */
        if (message.bucketName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.bucketName);
        /* int32 limit = 2; */
        if (message.limit !== 0)
            writer.tag(2, WireType.Varint).int32(message.limit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.GetImagesInBucketRequest
 */
export const GetImagesInBucketRequest = new GetImagesInBucketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetImagesInBucketResponse$Type extends MessageType<GetImagesInBucketResponse> {
    constructor() {
        super("s3.GetImagesInBucketResponse", [
            { no: 1, name: "images", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Image },
            { no: 2, name: "status", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetImagesInBucketResponse>): GetImagesInBucketResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.images = [];
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial<GetImagesInBucketResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetImagesInBucketResponse): GetImagesInBucketResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated s3.Image images */ 1:
                    message.images.push(Image.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 status */ 2:
                    message.status = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetImagesInBucketResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated s3.Image images = 1; */
        for (let i = 0; i < message.images.length; i++)
            Image.internalBinaryWrite(message.images[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).uint32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.GetImagesInBucketResponse
 */
export const GetImagesInBucketResponse = new GetImagesInBucketResponse$Type();
/**
 * @generated ServiceType for protobuf service s3.Endpoint
 */
export const Endpoint = new ServiceType("s3.Endpoint", [
    { name: "RegisterBucket", options: {}, I: RegisterBucketRequest, O: RegisterBucketResponse },
    { name: "HasBucket", options: {}, I: HasBucketRequest, O: HasBucketResponse },
    { name: "UnregisterBucket", options: {}, I: UnregisterBucketRequest, O: Response },
    { name: "GetAllBuckets", options: {}, I: GetAllBucketsRequest, O: GetAllBucketsResponse },
    { name: "CreateImage", options: {}, I: CreateImageRequest, O: CreateImageResponse },
    { name: "GetImage", options: {}, I: GetImageRequest, O: GetImageResponse },
    { name: "GetImageWithBucket", options: {}, I: GetImageWithBucketRequest, O: GetImageWithBucketResponse },
    { name: "DeleteImage", options: {}, I: DeleteImageRequest, O: Response },
    { name: "GetAllImages", options: {}, I: GetAllImagesRequest, O: GetAllImagesResponse },
    { name: "GetImagesInBucket", options: {}, I: GetImagesInBucketRequest, O: GetImagesInBucketResponse }
]);
