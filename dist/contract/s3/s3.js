// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "s3/s3.proto" (package "s3", syntax proto3)
// tslint:disable
import { Response } from "../common/common";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
// @generated message type with reflection information, may provide speed optimized methods
class Bucket$Type extends MessageType {
    constructor() {
        super("s3.Bucket", [
            { no: 1, name: "bucket_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.bucketName = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string bucket_name */ 1:
                    message.bucketName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string bucket_name = 1; */
        if (message.bucketName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.bucketName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.Bucket
 */
export const Bucket = new Bucket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Image$Type extends MessageType {
    constructor() {
        super("s3.Image", [
            { no: 1, name: "id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.id = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes id */ 1:
                    message.id = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes id = 1; */
        if (message.id.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.Image
 */
export const Image = new Image$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImageWithBucket$Type extends MessageType {
    constructor() {
        super("s3.ImageWithBucket", [
            { no: 1, name: "id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "bucket_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.id = new Uint8Array(0);
        message.bucketName = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes id */ 1:
                    message.id = reader.bytes();
                    break;
                case /* string bucket_name */ 2:
                    message.bucketName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes id = 1; */
        if (message.id.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.id);
        /* string bucket_name = 2; */
        if (message.bucketName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.bucketName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.ImageWithBucket
 */
export const ImageWithBucket = new ImageWithBucket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterBucketRequest$Type extends MessageType {
    constructor() {
        super("s3.RegisterBucketRequest", [
            { no: 1, name: "bucket_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.bucketName = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string bucket_name */ 1:
                    message.bucketName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string bucket_name = 1; */
        if (message.bucketName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.bucketName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.RegisterBucketRequest
 */
export const RegisterBucketRequest = new RegisterBucketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterBucketResponse$Type extends MessageType {
    constructor() {
        super("s3.RegisterBucketResponse", [
            { no: 1, name: "bucket", kind: "message", T: () => Bucket },
            { no: 2, name: "status", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* s3.Bucket bucket */ 1:
                    message.bucket = Bucket.internalBinaryRead(reader, reader.uint32(), options, message.bucket);
                    break;
                case /* uint32 status */ 2:
                    message.status = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* s3.Bucket bucket = 1; */
        if (message.bucket)
            Bucket.internalBinaryWrite(message.bucket, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).uint32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.RegisterBucketResponse
 */
export const RegisterBucketResponse = new RegisterBucketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HasBucketRequest$Type extends MessageType {
    constructor() {
        super("s3.HasBucketRequest", [
            { no: 1, name: "bucket_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.bucketName = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string bucket_name */ 1:
                    message.bucketName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string bucket_name = 1; */
        if (message.bucketName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.bucketName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.HasBucketRequest
 */
export const HasBucketRequest = new HasBucketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HasBucketResponse$Type extends MessageType {
    constructor() {
        super("s3.HasBucketResponse", [
            { no: 1, name: "exists", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "status", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.exists = false;
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool exists */ 1:
                    message.exists = reader.bool();
                    break;
                case /* uint32 status */ 2:
                    message.status = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool exists = 1; */
        if (message.exists !== false)
            writer.tag(1, WireType.Varint).bool(message.exists);
        /* uint32 status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).uint32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.HasBucketResponse
 */
export const HasBucketResponse = new HasBucketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnregisterBucketRequest$Type extends MessageType {
    constructor() {
        super("s3.UnregisterBucketRequest", [
            { no: 1, name: "bucket_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.bucketName = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string bucket_name */ 1:
                    message.bucketName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string bucket_name = 1; */
        if (message.bucketName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.bucketName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.UnregisterBucketRequest
 */
export const UnregisterBucketRequest = new UnregisterBucketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAllBucketsRequest$Type extends MessageType {
    constructor() {
        super("s3.GetAllBucketsRequest", []);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.GetAllBucketsRequest
 */
export const GetAllBucketsRequest = new GetAllBucketsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAllBucketsResponse$Type extends MessageType {
    constructor() {
        super("s3.GetAllBucketsResponse", [
            { no: 1, name: "buckets", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Bucket },
            { no: 2, name: "status", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.buckets = [];
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated s3.Bucket buckets */ 1:
                    message.buckets.push(Bucket.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 status */ 2:
                    message.status = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated s3.Bucket buckets = 1; */
        for (let i = 0; i < message.buckets.length; i++)
            Bucket.internalBinaryWrite(message.buckets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).uint32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.GetAllBucketsResponse
 */
export const GetAllBucketsResponse = new GetAllBucketsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateImageRequest$Type extends MessageType {
    constructor() {
        super("s3.CreateImageRequest", [
            { no: 1, name: "bucket_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "file", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "file_extension", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "quality", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "max_size", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "id", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.bucketName = "";
        message.file = new Uint8Array(0);
        message.fileExtension = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string bucket_name */ 1:
                    message.bucketName = reader.string();
                    break;
                case /* bytes file */ 2:
                    message.file = reader.bytes();
                    break;
                case /* string file_extension */ 3:
                    message.fileExtension = reader.string();
                    break;
                case /* optional float quality */ 4:
                    message.quality = reader.float();
                    break;
                case /* optional int32 max_size */ 5:
                    message.maxSize = reader.int32();
                    break;
                case /* optional bytes id */ 6:
                    message.id = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string bucket_name = 1; */
        if (message.bucketName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.bucketName);
        /* bytes file = 2; */
        if (message.file.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.file);
        /* string file_extension = 3; */
        if (message.fileExtension !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.fileExtension);
        /* optional float quality = 4; */
        if (message.quality !== undefined)
            writer.tag(4, WireType.Bit32).float(message.quality);
        /* optional int32 max_size = 5; */
        if (message.maxSize !== undefined)
            writer.tag(5, WireType.Varint).int32(message.maxSize);
        /* optional bytes id = 6; */
        if (message.id !== undefined)
            writer.tag(6, WireType.LengthDelimited).bytes(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.CreateImageRequest
 */
export const CreateImageRequest = new CreateImageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateImageResponse$Type extends MessageType {
    constructor() {
        super("s3.CreateImageResponse", [
            { no: 1, name: "image", kind: "message", T: () => Image },
            { no: 2, name: "status", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* s3.Image image */ 1:
                    message.image = Image.internalBinaryRead(reader, reader.uint32(), options, message.image);
                    break;
                case /* uint32 status */ 2:
                    message.status = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* s3.Image image = 1; */
        if (message.image)
            Image.internalBinaryWrite(message.image, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).uint32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.CreateImageResponse
 */
export const CreateImageResponse = new CreateImageResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetImageRequest$Type extends MessageType {
    constructor() {
        super("s3.GetImageRequest", [
            { no: 1, name: "id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.id = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes id */ 1:
                    message.id = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes id = 1; */
        if (message.id.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.GetImageRequest
 */
export const GetImageRequest = new GetImageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetImageResponse$Type extends MessageType {
    constructor() {
        super("s3.GetImageResponse", [
            { no: 1, name: "image", kind: "message", T: () => Image },
            { no: 2, name: "status", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* s3.Image image */ 1:
                    message.image = Image.internalBinaryRead(reader, reader.uint32(), options, message.image);
                    break;
                case /* uint32 status */ 2:
                    message.status = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* s3.Image image = 1; */
        if (message.image)
            Image.internalBinaryWrite(message.image, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).uint32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.GetImageResponse
 */
export const GetImageResponse = new GetImageResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetImageWithBucketRequest$Type extends MessageType {
    constructor() {
        super("s3.GetImageWithBucketRequest", [
            { no: 1, name: "id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.id = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes id */ 1:
                    message.id = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes id = 1; */
        if (message.id.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.GetImageWithBucketRequest
 */
export const GetImageWithBucketRequest = new GetImageWithBucketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetImageWithBucketResponse$Type extends MessageType {
    constructor() {
        super("s3.GetImageWithBucketResponse", [
            { no: 1, name: "image_with_bucket", kind: "message", T: () => ImageWithBucket },
            { no: 2, name: "status", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* s3.ImageWithBucket image_with_bucket */ 1:
                    message.imageWithBucket = ImageWithBucket.internalBinaryRead(reader, reader.uint32(), options, message.imageWithBucket);
                    break;
                case /* uint32 status */ 2:
                    message.status = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* s3.ImageWithBucket image_with_bucket = 1; */
        if (message.imageWithBucket)
            ImageWithBucket.internalBinaryWrite(message.imageWithBucket, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).uint32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.GetImageWithBucketResponse
 */
export const GetImageWithBucketResponse = new GetImageWithBucketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteImageRequest$Type extends MessageType {
    constructor() {
        super("s3.DeleteImageRequest", [
            { no: 1, name: "id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.id = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes id */ 1:
                    message.id = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes id = 1; */
        if (message.id.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.DeleteImageRequest
 */
export const DeleteImageRequest = new DeleteImageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAllImagesRequest$Type extends MessageType {
    constructor() {
        super("s3.GetAllImagesRequest", [
            { no: 1, name: "limit", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.limit = 0;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 limit */ 1:
                    message.limit = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* int32 limit = 1; */
        if (message.limit !== 0)
            writer.tag(1, WireType.Varint).int32(message.limit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.GetAllImagesRequest
 */
export const GetAllImagesRequest = new GetAllImagesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAllImagesResponse$Type extends MessageType {
    constructor() {
        super("s3.GetAllImagesResponse", [
            { no: 1, name: "images", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Image },
            { no: 2, name: "status", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.images = [];
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated s3.Image images */ 1:
                    message.images.push(Image.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 status */ 2:
                    message.status = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated s3.Image images = 1; */
        for (let i = 0; i < message.images.length; i++)
            Image.internalBinaryWrite(message.images[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).uint32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.GetAllImagesResponse
 */
export const GetAllImagesResponse = new GetAllImagesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetImagesInBucketRequest$Type extends MessageType {
    constructor() {
        super("s3.GetImagesInBucketRequest", [
            { no: 1, name: "bucket_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "limit", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.bucketName = "";
        message.limit = 0;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string bucket_name */ 1:
                    message.bucketName = reader.string();
                    break;
                case /* int32 limit */ 2:
                    message.limit = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string bucket_name = 1; */
        if (message.bucketName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.bucketName);
        /* int32 limit = 2; */
        if (message.limit !== 0)
            writer.tag(2, WireType.Varint).int32(message.limit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.GetImagesInBucketRequest
 */
export const GetImagesInBucketRequest = new GetImagesInBucketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetImagesInBucketResponse$Type extends MessageType {
    constructor() {
        super("s3.GetImagesInBucketResponse", [
            { no: 1, name: "images", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Image },
            { no: 2, name: "status", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.images = [];
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated s3.Image images */ 1:
                    message.images.push(Image.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 status */ 2:
                    message.status = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated s3.Image images = 1; */
        for (let i = 0; i < message.images.length; i++)
            Image.internalBinaryWrite(message.images[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).uint32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message s3.GetImagesInBucketResponse
 */
export const GetImagesInBucketResponse = new GetImagesInBucketResponse$Type();
/**
 * @generated ServiceType for protobuf service s3.Endpoint
 */
export const Endpoint = new ServiceType("s3.Endpoint", [
    { name: "RegisterBucket", options: {}, I: RegisterBucketRequest, O: RegisterBucketResponse },
    { name: "HasBucket", options: {}, I: HasBucketRequest, O: HasBucketResponse },
    { name: "UnregisterBucket", options: {}, I: UnregisterBucketRequest, O: Response },
    { name: "GetAllBuckets", options: {}, I: GetAllBucketsRequest, O: GetAllBucketsResponse },
    { name: "CreateImage", options: {}, I: CreateImageRequest, O: CreateImageResponse },
    { name: "GetImage", options: {}, I: GetImageRequest, O: GetImageResponse },
    { name: "GetImageWithBucket", options: {}, I: GetImageWithBucketRequest, O: GetImageWithBucketResponse },
    { name: "DeleteImage", options: {}, I: DeleteImageRequest, O: Response },
    { name: "GetAllImages", options: {}, I: GetAllImagesRequest, O: GetAllImagesResponse },
    { name: "GetImagesInBucket", options: {}, I: GetImagesInBucketRequest, O: GetImagesInBucketResponse }
]);
